**SENG 637 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 â€“ Requirements-Based Test Generation**

| Group: 4      |
|-----------------|
| Student 1 Arpita Chowdhury                |   
| Student 2 Fadila Abdulai Hamid             |   
| Student 3 Kumkum Akter             |   
| Student 4 Niloofar Sharifisadr              |
| Student 5 Pratishtha Pratishtha |  

**Table of Contents**

[1 Introduction	](#intro)

[2 Detailed description of unit test strategy](#hld)

[3 Test cases developed](#evm)

[4 How the team work/effort was divided and managed](#peer)

[5 Difficulties encountered, challenges overcome, and lessons learned](#team)

[6 Comments/feedback on the lab itself](#diff)

# 1 Introduction <a name="intro"></a>

This report aims to outline the unit testing strategy employed for the given System Under Test(SUT) and provide a detailed description of the test cases the group developed to check the validity of different functionalities or methods of the system. Unit testing is a fundamental aspect of software development aimed at verifying the correctness and robustness of individual units or components within a system in isolation, while testing techniques like Exploratory Testing focus on user experience and Manual Scripted Testing is based on predefined test cases.

This report will delve into the testing strategy utilized, i.e., the application of black-box testing techniques such as equivalence partitioning and boundary value analysis for different test cases. Additionally, we will discuss using mocking to isolate units under test from their dependencies, thus enabling focused and controlled testing scenarios.

By organizing the test cases based on the source code methods they test in the next section, we aim to clarify the coverage of different partitions outlined in the testing strategy. Each test case is designed to validate specific behaviors and edge cases, ensuring thorough testing of the software components.

Through this report, we aim to demonstrate a systematic approach to unit testing, emphasizing the importance of comprehensive testing methodologies in ensuring the reliability and correctness of software systems.

# 2 Detailed description of unit test strategy <a name="hld"></a>

Unit testing is an essential part of software development that ensures individual units or components of a system function correctly. This section discusses the testing strategy employed for unit testing in the context of two classes: `DataUtilities` and `Range` from the `org.jfree.data` package for the given JFreeChart library. In this assignment, we have implemented Black-box testing. This testing focuses on testing the functionality of a system without knowledge of its internal workings. Equivalence partitioning and boundary value analysis are critical techniques used in black-box testing.

## **Black-Box Testing Techniques:**

**Equivalence Partitioning:** The input domain is divided into equivalence classes, where inputs within the same class should produce the same results. Equivalence classes are identified based on the nature of the input data and the system's expected behavior.

**Boundary Value Analysis:** Boundary value analysis focuses on testing boundaries or edge cases of input ranges to ensure the robustness and correctness of the system. It involves testing values at the lower and upper bounds of input ranges and just above and below these boundaries.

Some other input partitioning are: **invalid inputs**(to check if a system can handle invalid inputs), **special cases**(if system can handle special values like NaN values), and **combination of inputs**(for a comprehensive test suite). We have discucced the corresponding test cases for these black box testing techniques in the next section. 

Another key concept that has been implemented is **Mocking**. Mocking simulates the behavior of dependencies or external systems in unit tests. It isolates units under test from their dependencies, enabling focused testing and controlled scenarios. Mock objects provide control over the behavior of dependencies, and so one needs not to rely on external systems or complex dependencies, and thus mocking is more efficient. We have implemented the same for the `DataUtilities` class, and is employed using the **JMock framework** to simulate the behavior of the `Values2D` interface, which represents a two-dimensional table of values.

# 3 Test cases developed <a name="evm"></a>

## 3.1. DataUtilities Class
### 3.1.1 DataUtilities.calculateColumnTotalTest

- **calculateColumnTotalForTwoValues()**
  - This test sets up a mocked Values2D object with two rows and two columns, specifically testing the calculation of the total for the first column, which contains the values 7.5 and 2.5. The expected outcome is a total of 10.0, verified through an assertion with a very small delta for floating-point comparison.

- **testCalculateColumnTotal_nullDataObjectPassed()**
  - Here, the method is tested with a null input for the Values2D object to check the method's robustness against null data scenarios. The test expects an InvalidParameterException to be thrown, validating the method's error handling.

- **testCalculateColumnTotal_invalidDataPassed()**
  - This scenario involves passing a Values2D object that returns non-numeric values (boolean true/false) for a given column, testing the method's ability to handle or reject invalid data types. The test's expected outcome is a specific assertion related to the handling of invalid data, although the assertion details may not align with realistic expectations of numeric calculations.

- **testCalculateColumnTotal_columnIsLastColumnInTable()**
  - A mocked Values2D setup returns numeric values for the last column in the table, testing whether the method can accurately calculate the total for columns at the end of the data range. The expected result is a total of 7.4, asserting the method's accuracy in total calculation.

- **testCalculateColumnTotal_columnIsFirstInTable()**
  - Similar to the previous, this test checks the calculation for the first column in a Values2D object setup with specific numeric values. It validates the method's ability to handle column totals at the beginning of the data table, with an expected total of 6.4.

- **testCalculateColumnTotal_columnIsNegativeOne()**
  - This test checks the method's response to an invalid column index of -1, expecting that the method will return a total of 0, indicating no calculation is performed for invalid column indices.

- **testCalculateColumnTotal_columnIsOneMoreThanMax()**
  - Testing the method's handling of out-of-bounds column indices, this scenario uses a column index that exceeds the table's column count. The expected behavior is that the method returns a total of 0.0, demonstrating proper error handling for out-of-bounds indices.

- **testCalculateColumnTotal_columnIsCentralInTable()**
  - Lastly, this test focuses on calculating the total for a central column within a Values2D object configured with specific values. It aims to verify the method's general functionality across different parts of the data table, with an expected accurate total of 6.4.
    
### 3.1.2 DataUtilities.calculateRowTotal Method
`calculateRowTotalMaxValueBoundary`: Covers the boundary case of the maximum double value, and thus testing if the system can handle such extreme values.
**Partitions Covered:** Boundary Value Analysis.

`calculateRowTotalMinValBoundary`: Covers the boundary case of the negative maximum double value, , and thus testing if the system can handle such extreme negative values.
**Partitions Covered:** Boundary Value Analysis.

`testCalculateRowTotalWithNullData`: Covers the behavior of calculateRowTotal method with a null data object, and thus ensuring if as the method suggests, the system will throw appropriate exception or not.
**Partitions Covered:** Equivalence Partitioning.

`calculateRowTotalInvalidIndex`: Covers the case where the calculateRowTotal method is called with an invalid (negative) row index, expecting an InvalidParameterException, as suggested in the Javadoc for an invalid index.
**Partitions Covered:** Equivalence Partitioning.

`calculateRowTotalValidRow`: Covers the normal functionality of the calculateRowTotal method with valid data to make sure the method works fine.
**Partitions Covered:** Equivalence Partitioning.
### 3.1.3 DataUtilities.CreateNumberArray2D
`testCreateNumberArray2D_BasicInput`: Tests if the method createNumberArray2D correctly converts a basic input array of doubles into a 2D array of Numbers. Test case failed.

`testCreateNumberArray2D_BoundaryValues`: Tests if the method handles boundary values (i.e., Double.MIN_VALUE and Double.MAX_VALUE) correctly. Test case failed.

`testCreateNumberArray2D_SpecialValues`: Tests if the method handles special values (NaN, positive and negative infinity) correctly. Test case failed.

`testCreateNumberArray2D_IrregularStructure`: Tests if the method correctly handles irregular structures in the input array, such as arrays with different lengths. Test case failed.

`testCreateNumberArray2D_LargeInput`: Tests the performance of the method with a large input array (1000x1000). Test case passed.

`testCreateNumberArray2D_EdgeCases`: Tests if the method correctly handles edge cases, such as an input array with only one element per row. Test case failed.

`testCreateNumberArray2D_NullInput`: Tests if the method throws an InvalidParameterException when a null input array is provided. Test cases failed.

`testCreateNumberArray2D_EmptyInput`: Tests if the method returns an empty array when an empty input array is provided. Test case passed.

`testCreateNumberArray2D_RandomizedInput`: Tests the method's behavior with randomized input arrays of size 5x5. Test case passed.

`testCreateNumberArray2D_Performance`: Tests the performance of the method by measuring its execution time with a large randomized input array (1000x1000). The test ensures that the execution time is reasonable (less than 1000 milliseconds). Test case passed.

### 3.1.4 DataUtilities.CreateNumberArray
I set {1.0, 2.5, 3.7, 4.2} as expected output for my test case.
`testCreateNumberArrayWithBottomLimitBoundary()`: Tested if it's converting a double array containing MIN_VALUE into a Number array. Test case failed as  in assertequalis expected and results are not the same type.
`testCreateNumberArrayWithLowerBoundary()`: Tested if it's converting a double array {-1.0, 0.0, 1.0} into a Number array. Test case failed as  in assertequalis expected and results are not the same type.
`testCreateNumberArrayWithAdjustedLowerBoundary()`: Tested if it's converting double same element of array {{1.0, 1.0, 1.0, 1.0} into a Number array. Test case failed as  in assertequalis expected and results are not the same type.
`testCreateNumberArrayWithSameValues()`: Tested if it's converting two MAX_VALUE elements double array into a Number array. Test case failed as  in assertequalis expected and results are not the same type.
`testCreateNumberArrayWithUpperBoundary()`: Tested if it's converting the double largest positive finite value into a Number array. Test case failed as  in assertequalis expected and results are not the same type.
`testCreateNumberArrayWithUpperLimitBoundary()`: Tested if it's converting the two MAX_VALUE as double type  into a Number array. Test case failed as  in assertequalis expected and results are not the same type.
`testCreateNumberArrayWithAdjustedUpperBoundary(): Tested if it's converting the exponential value that is double type into a Number array. Test case failed as  in assertequalis expected and results are not the same type.
`testCreateNumberArrayValidInput()`: Tested if it's converting the double value as similar input  {1.0, 2.5, 3.7, 4.2} into a Number array. Test case failed as  in assertequalis expected and results are not the same type.
`testCreateNumberArrayEmptyInput() `: Tested if it's converting an empty array as double type into a Number array.The test case passed.
`testCreateNumberArrayWithMixedValues()`: Tested if it's converting the double value as mixed positive and negetive input {-1.0, 2.5, 0.0, 4.2} into a Number array. Test case failed as  in assertequalis expected and results are not the same type.
`testCreateNumberArrayWithLargeInput()`: Tested if it's converting the large input array that is double into a Number array. Test case failed as  in assertequalis expected and results are not the same type.
`testCreateNumberArrayWithZeroValues()`: Tested if it's converting {0,0,0,0} input array that is double  into a Number array. Test case failed as  in assertequalis expected and results are not the same type.
`testCreateNumberArrayWithSingleElement()`: Tested if it's converting single array element that is double type into a Number array. Test case failed as  in assertequalis expected and results are not the same type.
`testCreateNumberArrayWithNaN()`: Tested if it's converting array containing NAN into a Number array. Test case failed as  in assertequalis expected and results are not the same type

## 3.2. Range Class
### 3.2.1 Range.combine Method
`testCombineWithOverlappingRanges`: Covers scenarios where two ranges overlap partially, to check if the final range combines them as expected.
**Partitions Covered:** Equivalence Partitioning, Boundary Value Analysis.

`testCombineWithNoOverlapInRanges`: Covers scenarios where two ranges have no overlap, yet if they can be combined as expected.
**Partitions Covered:** Equivalence Partitioning.

`testCombineWithIdenticalRanges`: Verifies that combining identical ranges returns the same range, as both have same lower and upper bound values.
**Partitions Covered:** Equivalence Partitioning.

`testCombineWithRangeBoundsDoubleLimits`: Verifies the behavior of the combine method with range bounds at the limits of Double, to see if a range can be formed by ranges from extremes of Double values.
**Partitions Covered:** Boundary Value Analysis.

`testCombineWithLargeRanges`: Covers scenarios where very large ranges are combined, and handled in time.
**Partitions Covered:** Equivalence Partitioning, Boundary Value Analysis.

`testCombineWithNaNValues`: Covers scenarios where ranges contain NaN values, to see if the method is designed to handle them appropriately.
**Partitions Covered:** Equivalence Partitioning.

`testCombineWithNullRange`: Verifies correct behavior when one range provided to the combine method is null, and if the method behaves as expected to output the other range.
**Partitions Covered:** Equivalence Partitioning.

`testCombineWithBothRangesNull`: Verifies correct behavior when both ranges provided to the combine method are null.
**Partitions Covered:** Equivalence Partitioning.
### 3.2.2 Range.contains Method
- **testContains_PositiveRange_ReturnsCorrectValue()**
  - This test case verifies if the contains method correctly identifies a value within a positive range. The Range object is initialized with a lower bound of 1.0 and an upper bound of 10.0. The method is expected to return true for     a value of 5.0, indicating that 5.0 is within the specified range. The test asserts this expected behavior using assertTrue.
- **testContains_PositiveRange_ReturnsFalseForValueLessThanMin()**
  - This test checks if the contains method returns false for a value less than the minimum boundary of a positive range. The Range is constructed with bounds of 1.0 and 10.0, and the method should report false when checking if 0.0     is contained within this range. The assertFalse method is used to validate this expectation.
- **testContains_PositiveRange_ReturnsFalseForValueGreaterThanMax()**
  - This test evaluates the contains method's ability to correctly identify a value that exceeds the upper limit of a positive range. With the Range set from 1.0 to 10.0, a value of 11.0 should be considered outside this range. The     expected result of false is confirmed using the assertFalse assertion.
- **testContains_NegativeRange_ReturnsCorrectValue()**
  - This test case assesses whether the contains method can accurately determine if a value is within a negative range. The Range object is initialized with bounds of -10.0 to -1.0, and the method should return true for a value of       -5.0, indicating its presence within the range. This behavior is verified with assertTrue.
- **testContains_NegativeRange_ReturnsFalseForValueLessThanMin()**
  - This test checks the functionality of the contains method for a value that is less than the minimum of a negative range. For a Range defined from -10.0 to -1.0, the method should report false when evaluating if -11.0 is              contained, as it is outside the range. The assertFalse method is used for this assertion.
- **testContains_NegativeRange_ReturnsFalseForValueGreaterThanMax()**
  - Here, the test case examines if the contains method accurately identifies values exceeding the maximum of a negative range. With the Range set between -10.0 and -1.0, a value of 0.0 is out of this range, and the method should       return false, as confirmed by the assertFalse assertion.
- **testContains_ZeroRange_ReturnsCorrectValue()**
  - This test evaluates the contains method's correctness in identifying a value within a zero range, where both the lower and upper bounds are 0.0. The method is expected to return true when checking if 0.0 is contained within this     range, indicating it is indeed within the bounds. The expected result is asserted with assertTrue.
- **testContains_ZeroRange_ReturnsFalseForNonZeroValue()**
  - The final test case checks if the contains method returns false for any non-zero value when the range is zero, i.e., both bounds are 0.0. The method should report false for a value of 1.0, as it does not fall within this specific   range. This behavior is validated using the assertFalse assertion.
### 3.2.3 Range.expandToInclude
`centralValueShouldBeZero`: Tested if the central value of a range with bounds -1 and 1 is indeed 0. Test case failed.

`expandToIncludeWithInputBLB`: Tested expanding the range to include a value that is just below the lower bound. Test case passed.

`expandToIncludeWithInputLB`: Tested if the range remains unchanged when trying to include a value equal to the lower bound. Test case passed.

`expandToIncludeWithInputALB`: Tested if the range remains unchanged when trying to include a value just above the lower bound. Test case failed.

`expandToIncludeWithInputBUB`: Tested if the range remains unchanged when trying to include a value just below the upper bound. Test case failed.

`expandToIncludeWithInputUB`: Tested if the range remains unchanged when trying to include a value equal to the upper bound. Test case failed.

`expandToIncludeWithInputAUB`: Tested expanding the range to include a value that is just above the upper bound. Test case failed.

`expandToIncludeWithInputPositive`: Tested expanding the range to include a positive value outside the current range. Test case failed.

`expandToIncludeWithInputNegative`: Tested expanding the range to include a negative value outside the current range. Test case passed.

`expandToIncludeWithInputDoubleMax`: Tested expanding the range to include the maximum possible double value. test case failed.

`expandToIncludeWithInputWithinRange`: Tested if the range remains unchanged when trying to include a value within the current range. Test case failed.

`expandToIncludeWithInputNegativeDoubleMax`: Tested expanding the range to include the negative maximum possible double value. Test case passed.

### 3.2.4 Range.Intersects
I set exampleRange to test here is (-10,10)

`intersectsWithInputBLBAndLB()`: The test case checks if there is overlap of expected value with test value. Here Below lower bound and lower bounds I checked are -10.00001, -10. The test case passed as it's overlapped with our example range.

`intersectsWithInputBLBAndALB()`: Covers test with if overlapping of below lower bound (-10.00001) and above lower bound (-9.99999). The test case failed as there was no intersection.

`intersectsWithInputBLBAndAUB()`: Covers test with if overlapping of below lower bound (-10.00001) and above upper  bound (10.00001). The test case passed as it intersects the examplerange.

`intersectsWithInputLBAndALB()`: Covers test with if overlapping of lower bound (-10) and above lower bound -9.99999. The test case passed.

`inintersectsWithInputLBAndUB()`: Covers test with if overlapping of below lower bound (-10) and above upper  bound (10). The test case passed as it intersects the examplerange.

`intersectsWithInputBLBAndAUB()`: Covers test with if overlapping of below lower bound (-10.00001) and above upper  bound (10.00001). The test case passed as it intersects the examplerange.
`intersectsWithInputNOMAndNOM()`: Covers test with if overlapping the nominal values (1,1). The test case passed.

`intersectsWithInputBUBAndUB()`: Covers test with if overlapping of below upper bound (9.99999) and  upper bound (10). The test case failed as there was no intersection.

`intersectsWithInputUBAndAUB()`: Covers test with if overlapping of upper bound (10) and above upper  bound (10.00001). TThe test case failed as there was no intersection.

`intersectsWithInputMINAndAUB()`: Covers test with if overlapping of MIN_VALUE and above upper  bound (10.00001). The test case failed.

`intersectsWithInputBLBAndMAX()`: Covers test with if overlapping of below lower bound (-10.00001) and MAX_VALUE. The test case failed.

`intersectsWithInput0And0()`: Covers test with if overlapping of (0,0). The test case failed.

`intersectsWithInputNaNAnd1() `: Covers test with if overlapping of (NaN,0). The test case failed.

# 4 How the team work/effort was divided and managed <a name="peer"></a>

Each of the five members complete unit tests for 1 method of the Range class and unit tests for 1 method of the DataUtilities class using jMock. Group peer review was be done after the individual testing to ensure that the quality of work abides to the scope of the test plan and for a fresh perspective on the designed test cases. Below table summarizes the distribution of development of test cases.
| API Range Method                                      | Tester                | 
| ----------------------------------------------- | --------------------- |
| Range.intersects(double, double)               | Arpita Chowdhury      |
| Range.getCentralValue()      | Fadila Abdulai Hamid |
| Range.expandtoinclude(Range range, double value)| Kumkum Akter          |
| Range.contains(double value)                         | Niloofar Sharifisadr  |
| Range.combine(Range range1, Range range2)      | Pratishtha Pratishtha |

| API DataUtilities Method                                      | Tester                | 
| ----------------------------------------------- | --------------------- |
| DataUtilities.createNumberArray(double[] data)               | Arpita Chowdhury      |
| DataUtilities.getCumulativePercentages(keyedValues data)      | Fadila Abdulai Hamid |
| DataUtilities.createNumberArray2D(double[] data)| Kumkum Akter          |
| DataUtilities.calculateColumnTotal(Values2D data, int coulmn)                         | Niloofar Sharifisadr  |
| DataUtilities.calculateRowTotal(Values2D data, int row)     | Pratishtha Pratishtha |

# 5 Difficulties encountered, challenges overcome, and lessons learned <a name="team"></a>

The challenge encountered in the test case involves setting up expectations for a mocked object using JMock in Java. Specifically, the difficulty arises when trying to handle cases where the method being tested is called with invalid parameters.
In this scenario, the calculateColumnTotal() method is being tested, and it is expected that the method behaves correctly when called with different column indices. However, handling cases where the column index exceeds the maximum allowed index proves to be challenging.
The error "unexpected invocation" occurs because the test case expects certain method calls on the mocked object, but the actual calls made during the test execution do not match these expectations. This discrepancy leads to test failures and highlights the need for precise setup of expectations in the test case.
To address this challenge, we made adjustments in the expectation setup to ensure that the mocked object behaves as expected when called with different column indices, including cases where the index is invalid. This involved setting up expectations to return default values or throw exceptions when invalid parameters are passed to the method being tested. The major challenge was when deciding to handle exceptions or understanding which extremes or special cases are actually catered to in the code in the calculateRowTotal() method. 
# 6 Comments/feedback on the lab itself <a name="diff"></a>


This lab was very helpful because it taught us how to use JUnit for Unit Testing and the approach was very differennt from the previous assignment. It's important to test software well, something that's not always given enough attention in software engineering. This was a practical code based assignment where we've really looked at how reliable software needs to be. We learned how critical even single bug in a program can be. The lab showed us how to make software that can test other software automatically, showing us how important it is to test everything carefully.
