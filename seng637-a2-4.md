**SENG 637 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group: 4      |
|-----------------|
| Student 1 Arpita Chowdhury                |   
| Student 2 Fadila Abdulai Hamid             |   
| Student 3 Kumkum Akter             |   
| Student 4 Niloofar Sharifisadr              |
| Student 5 Pratishtha Pratishtha |  

**Table of Contents**

[1 Introduction	](#intro)

[2 Detailed description of unit test strategy](#hld)

[3 Test cases developed](#evm)

[4 How the team work/effort was divided and managed](#peer)

[5 Difficulties encountered, challenges overcome, and lessons learned](#team)

[6 Comments/feedback on the lab itself](#diff)

# 1 Introduction <a name="intro"></a>

This report aims to outline the unit testing strategy employed for the given System Under Test(SUT) and provide a detailed description of the test cases the group developed to check the validity of different functionalities or methods of the system. Unit testing is a fundamental aspect of software development aimed at verifying the correctness and robustness of individual units or components within a system in isolation, while testing techniques like Exploratory Testing focus on user experience and Manual Scripted Testing is based on predefined test cases.

This report will delve into the testing strategy utilized, i.e., the application of black-box testing techniques such as equivalence partitioning and boundary value analysis for different test cases. Additionally, we will discuss using mocking to isolate units under test from their dependencies, thus enabling focused and controlled testing scenarios.

By organizing the test cases based on the source code methods they test in the next section, we aim to clarify the coverage of different partitions outlined in the testing strategy. Each test case is designed to validate specific behaviors and edge cases, ensuring thorough testing of the software components.

Through this report, we aim to demonstrate a systematic approach to unit testing, emphasizing the importance of comprehensive testing methodologies in ensuring the reliability and correctness of software systems.

# 2 Detailed description of unit test strategy <a name="hld"></a>

Unit testing is an essential part of software development that ensures individual units or components of a system function correctly. This section discusses the testing strategy employed for unit testing in the context of two classes: `DataUtilities` and `Range` from the `org.jfree.data` package for the given JFreeChart library. In this assignment, we have implemented Black-box testing. This testing focuses on testing the functionality of a system without knowledge of its internal workings. Equivalence partitioning and boundary value analysis are critical techniques used in black-box testing, apart from other input partitionings - invalid inputs, special cases, and combination of inputs.

**Black-Box Testing Techniques:**
**Equivalence Partitioning:** The input domain is divided into equivalence classes, where inputs within the same class should produce the same results. Equivalence classes are identified based on the nature of the input data and the system's expected behavior.

**Boundary Value Analysis:** Boundary value analysis focuses on testing boundaries or edge cases of input ranges to ensure the robustness and correctness of the system. It involves testing values at the lower and upper bounds of input ranges and just above and below these boundaries.

Mocking:
Mocking simulates the behavior of dependencies or external systems in unit tests. It isolates units under test from their dependencies, enabling focused testing and controlled scenarios.

# 3 Test cases developed <a name="evm"></a>

## 3.1. DataUtilities Class
## 3.2. Range Class
### 3.2.2 Range.contains Method
- **testContains_PositiveRange_ReturnsCorrectValue()
This test case verifies if the contains method correctly identifies a value within a positive range. The Range object is initialized with a lower bound of 1.0 and an upper bound of 10.0. The method is expected to return true for a value of 5.0, indicating that 5.0 is within the specified range. The test asserts this expected behavior using assertTrue.
- ** testContains_PositiveRange_ReturnsFalseForValueLessThanMin()
- This test checks if the contains method returns false for a value less than the minimum boundary of a positive range. The Range is constructed with bounds of 1.0 and 10.0, and the method should report false when checking if 0.0 is contained within this range. The assertFalse method is used to validate this expectation.
- ** testContains_PositiveRange_ReturnsFalseForValueGreaterThanMax()
- This test evaluates the contains method's ability to correctly identify a value that exceeds the upper limit of a positive range. With the Range set from 1.0 to 10.0, a value of 11.0 should be considered outside this range. The expected result of false is confirmed using the assertFalse assertion.
- ** testContains_NegativeRange_ReturnsCorrectValue()
- This test case assesses whether the contains method can accurately determine if a value is within a negative range. The Range object is initialized with bounds of -10.0 to -1.0, and the method should return true for a value of -5.0, indicating its presence within the range. This behavior is verified with assertTrue.
- ** testContains_NegativeRange_ReturnsFalseForValueLessThanMin()
- This test checks the functionality of the contains method for a value that is less than the minimum of a negative range. For a Range defined from -10.0 to -1.0, the method should report false when evaluating if -11.0 is contained, as it is outside the range. The assertFalse method is used for this assertion.
- ** testContains_NegativeRange_ReturnsFalseForValueGreaterThanMax()
- Here, the test case examines if the contains method accurately identifies values exceeding the maximum of a negative range. With the Range set between -10.0 and -1.0, a value of 0.0 is out of this range, and the method should return false, as confirmed by the assertFalse assertion.
- ** testContains_ZeroRange_ReturnsCorrectValue()
- This test evaluates the contains method's correctness in identifying a value within a zero range, where both the lower and upper bounds are 0.0. The method is expected to return true when checking if 0.0 is contained within this range, indicating it is indeed within the bounds. The expected result is asserted with assertTrue.
- ** testContains_ZeroRange_ReturnsFalseForNonZeroValue()
- The final test case checks if the contains method returns false for any non-zero value when the range is zero, i.e., both bounds are 0.0. The method should report false for a value of 1.0, as it does not fall within this specific range. This behavior is validated using the assertFalse assertion.


# 4 How the team work/effort was divided and managed <a name="peer"></a>

Text…

# 5 Difficulties encountered, challenges overcome, and lessons learned <a name="team"></a>

Text…

# 6 Comments/feedback on the lab itself <a name="diff"></a>

Text…
