**SENG 637 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group: 4      |
|-----------------|
| Student 1 Arpita Chowdhury                |   
| Student 2 Fadila Abdulai Hamid             |   
| Student 3 Kumkum Akter             |   
| Student 4 Niloofar Sharifisadr              |
| Student 5 Pratishtha Pratishtha |  

**Table of Contents**

[1 Introduction	](#intro)

[2 Detailed description of unit test strategy](#hld)

[3 Test cases developed](#evm)

[4 How the team work/effort was divided and managed](#peer)

[5 Difficulties encountered, challenges overcome, and lessons learned](#team)

[6 Comments/feedback on the lab itself](#diff)

# 1 Introduction <a name="intro"></a>

This report aims to outline the unit testing strategy employed for the given System Under Test(SUT) and provide a detailed description of the test cases the group developed to check the validity of different functionalities or methods of the system. Unit testing is a fundamental aspect of software development aimed at verifying the correctness and robustness of individual units or components within a system in isolation, while testing techniques like Exploratory Testing focus on user experience and Manual Scripted Testing is based on predefined test cases.

This report will delve into the testing strategy utilized, i.e., the application of black-box testing techniques such as equivalence partitioning and boundary value analysis for different test cases. Additionally, we will discuss using mocking to isolate units under test from their dependencies, thus enabling focused and controlled testing scenarios.

By organizing the test cases based on the source code methods they test in the next section, we aim to clarify the coverage of different partitions outlined in the testing strategy. Each test case is designed to validate specific behaviors and edge cases, ensuring thorough testing of the software components.

Through this report, we aim to demonstrate a systematic approach to unit testing, emphasizing the importance of comprehensive testing methodologies in ensuring the reliability and correctness of software systems.

# 2 Detailed description of unit test strategy <a name="hld"></a>

Unit testing is an essential part of software development that ensures individual units or components of a system function correctly. This section discusses the testing strategy employed for unit testing in the context of two classes: `DataUtilities` and `Range` from the `org.jfree.data` package for the given JFreeChart library. In this assignment, we have implemented Black-box testing. This testing focuses on testing the functionality of a system without knowledge of its internal workings. Equivalence partitioning and boundary value analysis are critical techniques used in black-box testing.

## **Black-Box Testing Techniques:**

**Equivalence Partitioning:** The input domain is divided into equivalence classes, where inputs within the same class should produce the same results. Equivalence classes are identified based on the nature of the input data and the system's expected behavior.

**Boundary Value Analysis:** Boundary value analysis focuses on testing boundaries or edge cases of input ranges to ensure the robustness and correctness of the system. It involves testing values at the lower and upper bounds of input ranges and just above and below these boundaries.

Some other input partitioning are: **invalid inputs**(to check if a system can handle invalid inputs), **special cases**(if system can handle special values like NaN values), and **combination of inputs**(for a comprehensive test suite). We have discucced the corresponding test cases for these black box testing techniques in the next section. 

Another key concept that has been implemented is **Mocking**. Mocking simulates the behavior of dependencies or external systems in unit tests. It isolates units under test from their dependencies, enabling focused testing and controlled scenarios. Mock objects provide control over the behavior of dependencies, and so one needs not to rely on external systems or complex dependencies, and thus mocking is more efficient. We have implemented the same for the `DataUtilities` class, and is employed using the **JMock framework** to simulate the behavior of the `Values2D` interface, which represents a two-dimensional table of values.

# 3 Test cases developed <a name="evm"></a>

## 3.1. DataUtilities Class
### 3.1.1 DataUtilities.calculateColumnTotalTest

- **calculateColumnTotalForTwoValues()**
  - This test sets up a mocked Values2D object with two rows and two columns, specifically testing the calculation of the total for the first column, which contains the values 7.5 and 2.5. The expected outcome is a total of 10.0, verified through an assertion with a very small delta for floating-point comparison.

- **testCalculateColumnTotal_nullDataObjectPassed()**
  - Here, the method is tested with a null input for the Values2D object to check the method's robustness against null data scenarios. The test expects an InvalidParameterException to be thrown, validating the method's error handling.

- **testCalculateColumnTotal_invalidDataPassed()**
  - This scenario involves passing a Values2D object that returns non-numeric values (boolean true/false) for a given column, testing the method's ability to handle or reject invalid data types. The test's expected outcome is a specific assertion related to the handling of invalid data, although the assertion details may not align with realistic expectations of numeric calculations.

- **testCalculateColumnTotal_columnIsLastColumnInTable()**
  - A mocked Values2D setup returns numeric values for the last column in the table, testing whether the method can accurately calculate the total for columns at the end of the data range. The expected result is a total of 7.4, asserting the method's accuracy in total calculation.

- **testCalculateColumnTotal_columnIsFirstInTable()**
  - Similar to the previous, this test checks the calculation for the first column in a Values2D object setup with specific numeric values. It validates the method's ability to handle column totals at the beginning of the data table, with an expected total of 6.4.

- **testCalculateColumnTotal_columnIsNegativeOne()**
  - This test checks the method's response to an invalid column index of -1, expecting that the method will return a total of 0, indicating no calculation is performed for invalid column indices.

- **testCalculateColumnTotal_columnIsOneMoreThanMax()**
  - Testing the method's handling of out-of-bounds column indices, this scenario uses a column index that exceeds the table's column count. The expected behavior is that the method returns a total of 0.0, demonstrating proper error handling for out-of-bounds indices.

- **testCalculateColumnTotal_columnIsCentralInTable()**
  - Lastly, this test focuses on calculating the total for a central column within a Values2D object configured with specific values. It aims to verify the method's general functionality across different parts of the data table, with an expected accurate total of 6.4.
    ### 3.1.3 DataUtilities.CreateNumberArray2D
`centralValueShouldBeZero`: Tested if the central value of a range with bounds -1 and 1 is indeed 0. Test case failed.

`expandToIncludeWithInputBLB`: Tested expanding the range to include a value that is just below the lower bound. Test case passed.

`expandToIncludeWithInputLB`: Tested if the range remains unchanged when trying to include a value equal to the lower bound. Test case passed.

`expandToIncludeWithInputALB`: Tested if the range remains unchanged when trying to include a value just above the lower bound. Test case failed.

`expandToIncludeWithInputBUB`: Tested if the range remains unchanged when trying to include a value just below the upper bound. Test case failed.

`expandToIncludeWithInputUB`: Tested if the range remains unchanged when trying to include a value equal to the upper bound. Test case failed.

`expandToIncludeWithInputAUB`: Tested expanding the range to include a value that is just above the upper bound. Test case failed.

`expandToIncludeWithInputPositive`: Tested expanding the range to include a positive value outside the current range. Test case failed.

`expandToIncludeWithInputNegative`: Tested expanding the range to include a negative value outside the current range. Test case passed.

`expandToIncludeWithInputDoubleMax`: Tested expanding the range to include the maximum possible double value. test case failed.

`expandToIncludeWithInputWithinRange`: Tested if the range remains unchanged when trying to include a value within the current range. Test case failed.

`expandToIncludeWithInputNegativeDoubleMax`: Tested expanding the range to include the negative maximum possible double value. Test case passed.

### 3.1.2 DataUtilities.calculateRowTotal Method
`calculateRowTotalMaxValueBoundary`: Covers the boundary case of the maximum double value.
**Partitions Covered:** Boundary Value Analysis.

`calculateRowTotalMinValBoundary`: Covers the boundary case of the negative maximum double value.
**Partitions Covered:** Boundary Value Analysis.

`testCalculateRowTotalWithNullData`: Covers the behavior of calculateRowTotal method with a null data object.
**Partitions Covered:** Equivalence Partitioning.

`calculateRowTotalInvalidIndex`: Covers the case where the calculateRowTotal method is called with an invalid (negative) row index, expecting an InvalidParameterException.
**Partitions Covered:** Equivalence Partitioning.

`calculateRowTotalValidRow`: Covers the normal functionality of the calculateRowTotal method with valid data.
**Partitions Covered:** Equivalence Partitioning.

## 3.2. Range Class
### 3.2.1 Range.combine Method
`testCombineWithOverlappingRanges`: Covers scenarios where two ranges overlap partially.
**Partitions Covered:** Equivalence Partitioning, Boundary Value Analysis.

`testCombineWithNoOverlapInRanges`: Covers scenarios where two ranges have no overlap.
**Partitions Covered:** Equivalence Partitioning.

`testCombineWithIdenticalRanges`: Verifies that combining identical ranges returns the same range.
**Partitions Covered:** Equivalence Partitioning.

`testCombineWithRangeBoundsDoubleLimits`: Verifies the behavior of the combine method with range bounds at the limits of Double.
**Partitions Covered:** Boundary Value Analysis.

`testCombineWithLargeRanges`: Covers scenarios where very large ranges are combined.
**Partitions Covered:** Equivalence Partitioning, Boundary Value Analysis.

`testCombineWithNaNValues`: Covers scenarios where ranges contain NaN values.
**Partitions Covered:** Equivalence Partitioning.

`testCombineWithNullRange`: Verifies correct behavior when one range provided to the combine method is null.
**Partitions Covered:** Equivalence Partitioning.

`testCombineWithBothRangesNull`: Verifies correct behavior when both ranges provided to the combine method are null.
**Partitions Covered:** Equivalence Partitioning.
### 3.2.2 Range.contains Method
- **testContains_PositiveRange_ReturnsCorrectValue()**
  - This test case verifies if the contains method correctly identifies a value within a positive range. The Range object is initialized with a lower bound of 1.0 and an upper bound of 10.0. The method is expected to return true for     a value of 5.0, indicating that 5.0 is within the specified range. The test asserts this expected behavior using assertTrue.
- **testContains_PositiveRange_ReturnsFalseForValueLessThanMin()**
  - This test checks if the contains method returns false for a value less than the minimum boundary of a positive range. The Range is constructed with bounds of 1.0 and 10.0, and the method should report false when checking if 0.0     is contained within this range. The assertFalse method is used to validate this expectation.
- **testContains_PositiveRange_ReturnsFalseForValueGreaterThanMax()**
  - This test evaluates the contains method's ability to correctly identify a value that exceeds the upper limit of a positive range. With the Range set from 1.0 to 10.0, a value of 11.0 should be considered outside this range. The     expected result of false is confirmed using the assertFalse assertion.
- **testContains_NegativeRange_ReturnsCorrectValue()**
  - This test case assesses whether the contains method can accurately determine if a value is within a negative range. The Range object is initialized with bounds of -10.0 to -1.0, and the method should return true for a value of       -5.0, indicating its presence within the range. This behavior is verified with assertTrue.
- **testContains_NegativeRange_ReturnsFalseForValueLessThanMin()**
  - This test checks the functionality of the contains method for a value that is less than the minimum of a negative range. For a Range defined from -10.0 to -1.0, the method should report false when evaluating if -11.0 is              contained, as it is outside the range. The assertFalse method is used for this assertion.
- **testContains_NegativeRange_ReturnsFalseForValueGreaterThanMax()**
  - Here, the test case examines if the contains method accurately identifies values exceeding the maximum of a negative range. With the Range set between -10.0 and -1.0, a value of 0.0 is out of this range, and the method should       return false, as confirmed by the assertFalse assertion.
- **testContains_ZeroRange_ReturnsCorrectValue()**
  - This test evaluates the contains method's correctness in identifying a value within a zero range, where both the lower and upper bounds are 0.0. The method is expected to return true when checking if 0.0 is contained within this     range, indicating it is indeed within the bounds. The expected result is asserted with assertTrue.
- **testContains_ZeroRange_ReturnsFalseForNonZeroValue()**
  - The final test case checks if the contains method returns false for any non-zero value when the range is zero, i.e., both bounds are 0.0. The method should report false for a value of 1.0, as it does not fall within this specific   range. This behavior is validated using the assertFalse assertion.


# 4 How the team work/effort was divided and managed <a name="peer"></a>

Each of the four members complete unit tests for 1 method of the Range class and unit tests for 1 method of the DataUtilities class using jMock. Group peer review will be done after the individual testing to ensure that the quality of work abides to the scope of the test plan. Below table summarizes the distribution of development of test cases.
| API Method                                      | Tester                | 
| ----------------------------------------------- | --------------------- |
| Range.intersects(double, double)               | Arpita Chowdhury      |
| Range.expandtoinclude(Range range, double value)| Kumkum Akter          |
| Range.contains(double value)                         | Niloofar Sharifisadr  |
| Range.combine(Range range1, Range range2)      | Pratishtha Pratishtha |


# 5 Difficulties encountered, challenges overcome, and lessons learned <a name="team"></a>

The challenge encountered in the test case involves setting up expectations for a mocked object using JMock in Java. Specifically, the difficulty arises when trying to handle cases where the method being tested is called with invalid parameters.
In this scenario, the calculateColumnTotal() method is being tested, and it is expected that the method behaves correctly when called with different column indices. However, handling cases where the column index exceeds the maximum allowed index proves to be challenging.
The error "unexpected invocation" occurs because the test case expects certain method calls on the mocked object, but the actual calls made during the test execution do not match these expectations. This discrepancy leads to test failures and highlights the need for precise setup of expectations in the test case.
To address this challenge, we made adjustments in the expectation setup to ensure that the mocked object behaves as expected when called with different column indices, including cases where the index is invalid. This involved setting up expectations to return default values or throw exceptions when invalid parameters are passed to the method being tested.
# 6 Comments/feedback on the lab itself <a name="diff"></a>


This lab was very helpful because it taught us how to use JUnit for finding and fixing bugs. It's important to test software well, something that's not always given enough attention in software engineering. This is the first class where we've really looked at how reliable software needs to be. We learned that even one small mistake in a program can cause big problems. The lab showed us how to make software that can test other software automatically, showing us how important it is to test everything carefully.…
